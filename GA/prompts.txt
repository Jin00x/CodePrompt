```rust
use std::fmt::Debug;

#[derive(Debug)]
pub struct Node<T: Debug> {
    pub value: T,
    pub next: Option<Box<Node<T>>>,
}

impl<T: Debug> Node<T> {
    pub fn new(value: T) -> Self {
        Self { value, next: None }
    }
}

#[derive(Debug)]
pub struct SinglyLinkedList<T: Debug> {
    head: Option<Box<Node<T>>>,
}

impl<T: Debug> Default for SinglyLinkedList<T> {
    fn default() -> Self {
        Self::new()
    }
}

impl<T: Debug> SinglyLinkedList<T> {
    pub fn new() -> Self {
        Self { head: None }
    }

    pub fn push_front(&mut self, value: T) {
        let new_node = Box::new(Node {
            value,
            next: self.head.take(),
        });
        self.head = Some(new_node);
    }

    pub fn push_back(&mut self, value: T) {
        let mut new_node = Box::new(Node::new(value));
        if let Some(mut head) = self.head.as_mut() {
            while let Some(ref mut next) = head.next {
                head = next;
            }
            head.next = Some(new_node);
        } else {
            self.head = Some(new_node);
        }
    }

    pub fn pop_front(&mut self) -> Option<T> {
        if let Some(node) = self.head.take() {
            self.head = node.next;
            Some(node.value)
        } else {
            None
        }
    }

    pub fn pop_back(&mut self) -> Option<T> {
        match self.head.take() {
            None => None,
            Some(mut head) => {
                if head.next.is_none() {
                    Some(head.value)
                } else {
                    let mut second_last = &mut head;
                    while let Some(ref mut next) = second_last.next {
                        if next.next.is_none() {
                            break;
                        }
                        second_last = next;
                    }
                    let last_node = second_last.next.take();
                    self.head = Some(head);
                    last_node.map(|node| node.value)
                }
            }
        }
    }

    pub fn from_vec(mut vec: Vec<T>) -> Self {
        vec.reverse();
        let mut list = Self::new();
        for val in vec {
            list.push_front(val);
        }
        list
    }

    pub fn into_vec(mut self) -> Vec<T> {
        let mut vec = Vec::new();
        while let Some(val) = self.pop_front() {
            vec.push(val);
        }
        vec
    }

    pub fn length(&self) -> usize {
        let mut count = 0;
        let mut current = self.head.as_ref();
        while let Some(node) = current {
            count += 1;
            current = node.next.as_ref();
        }
        count
    }

    pub fn map<F: Fn(T) -> T>(self, f: F) -> Self {
        let mut new_list = Self::new();
        let mut current = self.head;
        while let Some(node) = current {
            new_list.push_back(f(node.value));
            current = node.next;
        }
        new_list
    }

    pub fn pair_map<F: Fn(T, T) -> T>(self, f: F) -> Self
    where
        T: Clone,
    {
        let mut new_list = Self::new();
        let mut current = self.head;
        while let Some(node) = current {
            if let Some(next_node) = node.next {
                new_list.push_back(f(node.value.clone(), next_node.value.clone()));
                current = Some(next_node);
            } else {
                break;
            }
        }
        new_list
    }
}

impl<T: Debug> SinglyLinkedList<SinglyLinkedList<T>> {
    pub fn flatten(self) -> SinglyLinkedList<T> {
        let mut flat_list = SinglyLinkedList::new();
        let mut current = self.head;
        while let Some(node) = current {
            let sublist = node.value;
            let mut sub_current = sublist.head;
            while let Some(sub_node) = sub_current {
                flat_list.push_back(sub_node.value);
                sub_current = sub_node.next;
            }
            current = node.next;
        }
        flat_list
    }
}
```
```rust
use std::fmt::Debug;

/// Node of the list.
#[derive(Debug)]
pub struct Node<T: Debug> {
    /// Value of current node.
    pub value: T,

    /// Pointer to the next node. If it is `None`, there is no next node.
    pub next: Option<Box<Node<T>>>,
}

impl<T: Debug> Node<T> {
    /// Creates a new node.
    pub fn new(value: T) -> Self {
        Self { value, next: None }
    }
}

/// A singly-linked list.
#[derive(Debug)]
pub struct SinglyLinkedList<T: Debug> {
    /// Head node of the list. If it is `None`, the list is empty.
    head: Option<Box<Node<T>>>,
}

impl<T: Debug> Default for SinglyLinkedList<T> {
    fn default() -> Self {
        Self::new()
    }
}

impl<T: Debug> SinglyLinkedList<T> {
    /// Creates a new list.
    pub fn new() -> Self {
        Self { head: None }
    }

    /// Adds the given node to the front of the list.
    pub fn push_front(&mut self, value: T) {
        let new_node = Box::new(Node {
            value,
            next: self.head.take(),
        });
        self.head = Some(new_node);
    }

    /// Adds the given node to the back of the list.
    pub fn push_back(&mut self, value: T) {
        let mut new_node = Box::new(Node::new(value));
        if let Some(mut current) = &mut self.head {
            while let Some(next) = &mut current.next {
                current = next;
            }
            current.next = Some(new_node);
        } else {
            self.head = Some(new_node);
        }
    }

    /// Removes and returns the node at the front of the list.
    pub fn pop_front(&mut self) -> Option<T> {
        self.head.take().map(|node| {
            self.head = node.next;
            node.value
        })
    }

    /// Removes and returns the node at the back of the list.
    pub fn pop_back(&mut self) -> Option<T> {
        let mut current = &mut self.head;
        while let Some(ref mut node) = current {
            if node.next.is_none() {
                return Some(current.take().unwrap().value);
            }
            current = &mut node.next;
        }
        None
    }

    /// Create a new list from the given vector `vec`.
    pub fn from_vec(vec: Vec<T>) -> Self {
        let mut list = SinglyLinkedList::new();
        for value in vec.into_iter().rev() {
            list.push_front(value);
        }
        list
    }

    /// Convert the current list into a vector.
    pub fn into_vec(mut self) -> Vec<T> {
        let mut vec = Vec::new();
        while let Some(value) = self.pop_front() {
            vec.push(value);
        }
        vec
    }

    /// Return the length (i.e., number of nodes) of the list.
    pub fn length(&self) -> usize {
        let mut count = 0;
        let mut current = &self.head;
        while let Some(node) = current {
            count += 1;
            current = &node.next;
        }
        count
    }

    /// Apply function `f` on every element of the list.
    pub fn map<F: Fn(T) -> T>(self, f: F) -> Self {
        let mut new_list = SinglyLinkedList::new();
        let mut current = &self.head;
        while let Some(node) = current {
            new_list.push_back(f(node.value.clone()));
            current = &node.next;
        }
        new_list
    }

    /// Apply given function `f` for each adjacent pair of elements in the list.
    pub fn pair_map<F: Fn(T, T) -> T>(mut self, f: F) -> Self
    where
        T: Clone,
    {
        let mut new_list = SinglyLinkedList::new();
        if self.length() < 2 {
            return new_list;
        }

        if let Some(mut node) = self.head.take() {
            while let Some(next) = node.next.take() {
                let pair_value = f(node.value.clone(), next.value.clone());
                new_list.push_back(pair_value);
                node = next;
            }
        }
        new_list
    }
}

impl<T: Debug> SinglyLinkedList<SinglyLinkedList<T>> {
    /// Flatten the list of lists into a single list.
    pub fn flatten(mut self) -> SinglyLinkedList<T> {
        let mut result = SinglyLinkedList::new();
        while let Some(inner_list) = self.pop_front() {
            let mut inner_list = inner_list;
            while let Some(value) = inner_list.pop_front() {
                result.push_back(value);
            }
        }
        result
    }
}
```
```rust
use std::fmt::Debug;

#[derive(Debug)]
pub struct Node<T: Debug> {
    pub value: T,
    pub next: Option<Box<Node<T>>>,
}

impl<T: Debug> Node<T> {
    pub fn new(value: T) -> Self {
        Self { value, next: None }
    }
}

#[derive(Debug)]
pub struct SinglyLinkedList<T: Debug> {
    head: Option<Box<Node<T>>>,
}

impl<T: Debug> Default for SinglyLinkedList<T> {
    fn default() -> Self {
        Self::new()
    }
}

impl<T: Debug> SinglyLinkedList<T> {
    pub fn new() -> Self {
        Self { head: None }
    }

    pub fn push_front(&mut self, value: T) {
        let mut new_node = Box::new(Node::new(value));
        new_node.next = self.head.take();
        self.head = Some(new_node);
    }

    pub fn push_back(&mut self, value: T) {
        let mut new_node = Box::new(Node::new(value));
        let mut current = &mut self.head;
        
        while let Some(ref mut node) = current {
            current = &mut node.next;
        }
        
        *current = Some(new_node);
    }

    pub fn pop_front(&mut self) -> Option<T> {
        self.head.take().map(|node| {
            let node = *node;
            self.head = node.next;
            node.value
        })
    }

    pub fn pop_back(&mut self) -> Option<T> {
        let mut current = &mut self.head;
        let mut prev: Option<&mut Box<Node<T>>> = None;
        
        while let Some(ref mut node) = current {
            if node.next.is_none() {
                break;
            }
            prev = current.as_mut();
            current = &mut node.next;
        }
        
        prev.map_or_else(
            || self.head.take().map(|node| (*node).value),
            |prev_node| {
                prev_node.next.take().map(|node| {
                    let node = *node;
                    node.value
                })
            },
        )
    }

    pub fn from_vec(vec: Vec<T>) -> Self {
        let mut list = SinglyLinkedList::new();
        for value in vec.into_iter().rev() {
            list.push_front(value);
        }
        list
    }

    pub fn into_vec(self) -> Vec<T> {
        let mut vec = Vec::new();
        let mut current = self.head;
        while let Some(node) = current {
            vec.push(node.value);
            current = node.next;
        }
        vec
    }

    pub fn length(&self) -> usize {
        let mut count = 0;
        let mut current = &self.head;
        while let Some(ref node) = current {
            count += 1;
            current = &node.next;
        }
        count
    }

    pub fn map<F: Fn(T) -> T>(self, f: F) -> Self {
        let mut list = SinglyLinkedList::new();
        let mut current = self.head;
        while let Some(node) = current {
            list.push_back(f(node.value));
            current = node.next;
        }
        list
    }

    pub fn pair_map<F: Fn(T, T) -> T>(self, f: F) -> Self
    where
        T: Clone,
    {
        if self.length() < 2 {
            return self;
        }

        let mut list = SinglyLinkedList::new();
        let mut current = self.head;

        while let Some(first_node) = current {
            if let Some(second_node) = first_node.next {
                list.push_back(f(first_node.value.clone(), second_node.value.clone()));
                current = second_node.next;
            } else {
                break;
            }
        }
        list
    }
}

impl<T: Debug> SinglyLinkedList<SinglyLinkedList<T>> {
    pub fn flatten(self) -> SinglyLinkedList<T> {
        let mut result = SinglyLinkedList::new();
        let mut current = self.head;
        while let Some(mut list_node) = current {
            while let Some(value) = list_node.value.pop_front() {
                result.push_back(value);
            }
            current = list_node.next;
        }
        result
    }
}
```
```rust
use std::fmt::Debug;

/// Node of the list.
#[derive(Debug)]
pub struct Node<T: Debug> {
    /// Value of current node.
    pub value: T,

    /// Pointer to the next node. If it is `None`, there is no next node.
    pub next: Option<Box<Node<T>>>,
}

impl<T: Debug> Node<T> {
    /// Creates a new node.
    pub fn new(value: T) -> Self {
        Self { value, next: None }
    }
}

/// A singly-linked list.
#[derive(Debug)]
pub struct SinglyLinkedList<T: Debug> {
    /// Head node of the list. If it is `None`, the list is empty.
    head: Option<Box<Node<T>>>,
}

impl<T: Debug> Default for SinglyLinkedList<T> {
    fn default() -> Self {
        Self::new()
    }
}

impl<T: Debug> SinglyLinkedList<T> {
    /// Creates a new list.
    pub fn new() -> Self {
        Self { head: None }
    }

    /// Adds the given node to the front of the list.
    pub fn push_front(&mut self, value: T) {
        let new_node = Box::new(Node {
            value,
            next: self.head.take(),
        });
        self.head = Some(new_node);
    }

    /// Adds the given node to the back of the list.
    pub fn push_back(&mut self, value: T) {
        let new_node = Box::new(Node::new(value));

        if self.head.is_none() {
            self.head = Some(new_node);
        } else {
            let mut current = self.head.as_mut().unwrap();
            while let Some(ref mut next) = current.next {
                current = next;
            }
            current.next = Some(new_node);
        }
    }

    /// Removes and returns the node at the front of the list.
    pub fn pop_front(&mut self) -> Option<T> {
        self.head.take().map(|head| {
            self.head = head.next;
            head.value
        })
    }

    /// Removes and returns the node at the back of the list.
    pub fn pop_back(&mut self) -> Option<T> {
        let mut current = &mut self.head;

        while let Some(ref mut node) = current {
            if node.next.is_some() && node.next.as_ref().unwrap().next.is_none() {
                let last_node = node.next.take();
                return Some(last_node.unwrap().value);
            }
            current = &mut node.next;
        }
        None
    }

    /// Create a new list from the given vector `vec`.
    pub fn from_vec(vec: Vec<T>) -> Self {
        let mut list = Self::new();
        for value in vec.into_iter().rev() {
            list.push_front(value);
        }
        list
    }

    /// Convert the current list into a vector.
    pub fn into_vec(self) -> Vec<T> {
        let mut vec = Vec::new();
        let mut current = self.head;

        while let Some(node) = current {
            vec.push(node.value);
            current = node.next;
        }
        vec
    }

    /// Return the length (i.e., number of nodes) of the list.
    pub fn length(&self) -> usize {
        let mut length = 0;
        let mut current = &self.head;
        while let Some(node) = current {
            length += 1;
            current = &node.next;
        }
        length
    }

    /// Apply function `f` on every element of the list.
    pub fn map<F: Fn(T) -> T>(self, f: F) -> Self {
        let mut result = SinglyLinkedList::new();
        let mut current = self.head;

        while let Some(node) = current {
            result.push_back(f(node.value));
            current = node.next;
        }
        result
    }

    /// Apply given function `f` for each adjacent pair of elements in the list.
    pub fn pair_map<F: Fn(T, T) -> T>(self, f: F) -> Self
    where
        T: Clone,
    {
        let mut result = SinglyLinkedList::new();
        if let Some(head) = self.head {
            let mut current = head;
            while let Some(next) = current.next {
                result.push_back(f(current.value.clone(), next.value.clone()));
                current = *next;
            }
        }
        result
    }
}

// A list of lists.
impl<T: Debug> SinglyLinkedList<SinglyLinkedList<T>> {
    /// Flatten the list of lists into a single list.
    pub fn flatten(self) -> SinglyLinkedList<T> {
        let mut result = SinglyLinkedList::new();
        let mut current = self.head;

        while let Some(node) = current {
            let inner_list = node.value.into_vec();
            for value in inner_list {
                result.push_back(value);
            }
            current = node.next;
        }
        result
    }
}
```
```rust
use std::fmt::Debug;

/// Node of the list.
#[derive(Debug)]
pub struct Node<T: Debug> {
    /// Value of current node.
    pub value: T,

    /// Pointer to the next node. If it is `None`, there is no next node.
    pub next: Option<Box<Node<T>>>,
}

impl<T: Debug> Node<T> {
    /// Creates a new node.
    pub fn new(value: T) -> Self {
        Self { value, next: None }
    }
}

/// A singly-linked list.
#[derive(Debug)]
pub struct SinglyLinkedList<T: Debug> {
    /// Head node of the list. If it is `None`, the list is empty.
    head: Option<Box<Node<T>>>,

    /// Tail node of the list for efficient back operations.
    tail: *mut Node<T>,
}

impl<T: Debug> Default for SinglyLinkedList<T> {
    fn default() -> Self {
        Self::new()
    }
}

impl<T: Debug> SinglyLinkedList<T> {
    /// Creates a new list.
    pub fn new() -> Self {
        Self { head: None, tail: std::ptr::null_mut() }
    }

    /// Adds the given node to the front of the list.
    pub fn push_front(&mut self, value: T) {
        let mut new_node = Box::new(Node::new(value));
        if self.head.is_none() {
            let node_ptr = &mut *new_node as *mut _;
            self.tail = node_ptr;
        }
        new_node.next = self.head.take();
        self.head = Some(new_node);
    }

    /// Adds the given node to the back of the list.
    pub fn push_back(&mut self, value: T) {
        let mut new_node = Box::new(Node::new(value));
        let node_ptr = &mut *new_node as *mut _;

        if self.tail.is_null() {
            self.head = Some(new_node);
            self.tail = node_ptr;
        } else {
            unsafe {
                (*self.tail).next = Some(new_node);
            }
            self.tail = node_ptr;
        }
    }

    /// Removes and returns the node at the front of the list.
    pub fn pop_front(&mut self) -> Option<T> {
        if let Some(mut old_head) = self.head.take() {
            self.head = old_head.next.take();
            if self.head.is_none() {
                self.tail = std::ptr::null_mut();
            }
            return Some(old_head.value);
        }
        None
    }

    /// Removes and returns the node at the back of the list.
    pub fn pop_back(&mut self) -> Option<T> {
        if self.head.is_none() {
            return None;
        }
        
        if self.head.as_ref().unwrap().next.is_none() {
            let value = self.head.take().map(|node| node.value);
            self.tail = std::ptr::null_mut();
            return value;
        }

        let mut current = &mut self.head;
        while let Some(ref mut curr) = current {
            if curr.next.as_ref().unwrap().next.is_none() {
                let value = curr.next.take().map(|node| node.value);
                self.tail = curr as *mut _;
                return value;
            }
            current = &mut curr.next;
        }
        None
    }

    /// Create a new list from the given vector `vec`.
    pub fn from_vec(mut vec: Vec<T>) -> Self {
        let mut list = Self::new();
        for value in vec.drain(..) {
            list.push_back(value);
        }
        list
    }

    /// Convert the current list into a vector.
    pub fn into_vec(mut self) -> Vec<T> {
        let mut vec = Vec::new();
        while let Some(value) = self.pop_front() {
            vec.push(value);
        }
        vec
    }

    /// Return the length (i.e., number of nodes) of the list.
    pub fn length(&self) -> usize {
        let mut length = 0;
        let mut current = &self.head;
        while let Some(ref node) = current {
            length += 1;
            current = &node.next;
        }
        length
    }

    /// Apply function `f` on every element of the list.
    pub fn map<F: Fn(T) -> T>(self, f: F) -> Self {
        let mut result = Self::new();
        let mut current = self.head;
        while let Some(mut node) = current {
            result.push_back(f(node.value));
            current = node.next.take();
        }
        result
    }

    /// Apply given function `f` for each adjacent pair of elements in the list.
    pub fn pair_map<F: Fn(T, T) -> T>(self, f: F) -> Self
    where
        T: Clone,
    {
        if self.length() < 2 {
            return Self::new();
        }

        let mut result = Self::new();
        let mut current = self.head;
        while let Some(node1) = current {
            if let Some(ref node2) = node1.next {
                result.push_back(f(node1.value.clone(), node2.value.clone()));
            }
            current = node1.next.map(|b| *b);
        }
        result
    }
}

// A list of lists.
impl<T: Debug> SinglyLinkedList<SinglyLinkedList<T>> {
    /// Flatten the list of lists into a single list.
    pub fn flatten(self) -> SinglyLinkedList<T> {
        let mut result = SinglyLinkedList::new();
        let mut current = self.head;
        while let Some(node) = current {
            let sublist = node.value;
            let items = sublist.into_vec();
            for item in items {
                result.push_back(item);
            }
            current = node.next.map(|b| *b);
        }
        result
    }
}
```
```rust
use std::fmt::Debug;

/// Node of the list.
#[derive(Debug)]
pub struct Node<T: Debug> {
    /// Value of current node.
    pub value: T,

    /// Pointer to the next node. If it is `None`, there is no next node.
    pub next: Option<Box<Node<T>>>,
}

impl<T: Debug> Node<T> {
    /// Creates a new node.
    pub fn new(value: T) -> Self {
        Self { value, next: None }
    }
}

/// A singly-linked list.
#[derive(Debug)]
pub struct SinglyLinkedList<T: Debug> {
    /// Head node of the list. If it is `None`, the list is empty.
    head: Option<Box<Node<T>>>,
}

impl<T: Debug> Default for SinglyLinkedList<T> {
    fn default() -> Self {
        Self::new()
    }
}

impl<T: Debug> SinglyLinkedList<T> {
    /// Creates a new list.
    pub fn new() -> Self {
        Self { head: None }
    }

    /// Adds the given node to the front of the list.
    pub fn push_front(&mut self, value: T) {
        let new_node = Box::new(Node::new(value));
        let old_head = self.head.take();
        self.head = Some(new_node);
        if let Some(node) = &mut self.head {
            node.next = old_head;
        }
    }

    /// Adds the given node to the back of the list.
    pub fn push_back(&mut self, value: T) {
        let mut new_node = Box::new(Node::new(value));
        if let Some(mut node) = self.head.as_mut() {
            while let Some(next) = &mut node.next {
                node = next;
            }
            node.next = Some(new_node);
        } else {
            self.head = Some(new_node);
        }
    }

    /// Removes and returns the node at the front of the list.
    pub fn pop_front(&mut self) -> Option<T> {
        self.head.take().map(|node| {
            self.head = node.next;
            node.value
        })
    }

    /// Removes and returns the node at the back of the list.
    pub fn pop_back(&mut self) -> Option<T> {
        let mut current = self.head.as_mut()?;
        let mut prev = None;

        while let Some(next) = &mut current.next {
            prev = Some(current);
            current = next;
        }

        if let Some(prev_node) = prev {
            prev_node.next = None;
        } else {
            self.head = None;
        }

        Some(current.value)
    }

    /// Create a new list from the given vector `vec`.
    pub fn from_vec(vec: Vec<T>) -> Self {
        let mut list = Self::new();
        for value in vec.into_iter() {
            list.push_back(value);
        }
        list
    }

    /// Convert the current list into a vector.
    pub fn into_vec(self) -> Vec<T> {
        let mut vec = Vec::new();
        let mut current = self.head;

        while let Some(node) = current {
            vec.push(node.value);
            current = node.next;
        }

        vec
    }

    /// Return the length (i.e., number of nodes) of the list.
    pub fn length(&self) -> usize {
        let mut count = 0;
        let mut current = &self.head;

        while let Some(node) = current {
            count += 1;
            current = &node.next;
        }

        count
    }

    /// Apply function `f` on every element of the list.
    pub fn map<F: Fn(T) -> T>(self, f: F) -> Self {
        let mut list = Self::new();
        let vec: Vec<T> = self.into_vec().into_iter().map(f).collect();

        for item in vec {
            list.push_back(item);
        }
        list
    }

    /// Apply given function `f` for each adjacent pair of elements in the list.
    pub fn pair_map<F: Fn(T, T) -> T>(self, f: F) -> Self
    where
        T: Clone,
    {
        let mut list = Self::new();
        let vec: Vec<T> = self.into_vec();
        let vec_pairs = vec.windows(2).map(|pair| f(pair[0].clone(), pair[1].clone()));

        for item in vec_pairs {
            list.push_back(item);
        }
        list
    }
}

// A list of lists.
impl<T: Debug> SinglyLinkedList<SinglyLinkedList<T>> {
    /// Flatten the list of lists into a single list.
    pub fn flatten(self) -> SinglyLinkedList<T> {
        let mut flat_list = SinglyLinkedList::new();

        let mut current = self.head;
        while let Some(node) = current {
            let inner_list = node.value;
            flat_list.extend(inner_list);
            current = node.next;
        }
        flat_list
    }
}

impl<T: Debug> SinglyLinkedList<T> {
    fn extend(&mut self, other: SinglyLinkedList<T>) {
        let mut current = other.head;
        while let Some(node) = current {
            self.push_back(node.value);
            current = node.next;
        }
    }
}
```
```rust
use std::fmt::Debug;

#[derive(Debug)]
pub struct Node<T: Debug> {
    pub value: T,
    pub next: Option<Box<Node<T>>>,
}

impl<T: Debug> Node<T> {
    pub fn new(value: T) -> Self {
        Self { value, next: None }
    }
}

#[derive(Debug)]
pub struct SinglyLinkedList<T: Debug> {
    head: Option<Box<Node<T>>>,
}

impl<T: Debug> Default for SinglyLinkedList<T> {
    fn default() -> Self {
        Self::new()
    }
}

impl<T: Debug> SinglyLinkedList<T> {
    pub fn new() -> Self {
        Self { head: None }
    }

    pub fn push_front(&mut self, value: T) {
        let new_node = Box::new(Node {
            value,
            next: self.head.take(),
        });
        self.head = Some(new_node);
    }

    pub fn push_back(&mut self, value: T) {
        let mut new_node = Box::new(Node::new(value));
        if let Some(mut current) = self.head.as_mut() {
            while let Some(next) = current.next.as_mut() {
                current = next;
            }
            current.next = Some(new_node);
        } else {
            self.head = Some(new_node);
        }
    }

    pub fn pop_front(&mut self) -> Option<T> {
        self.head.take().map(|node| {
            self.head = node.next;
            node.value
        })
    }

    pub fn pop_back(&mut self) -> Option<T> {
        let mut current = self.head.as_mut();
        if current.is_none() {
            return None;
        }
        let mut prev: Option<&mut Box<Node<T>>> = None;
        while let Some(ref mut node) = current {
            if node.next.is_none() {
                let value = node.value;
                if let Some(previous) = prev {
                    previous.next = None;
                } else {
                    self.head = None;
                }
                return Some(value);
            }
            prev = current.take();
            current = node.next.as_mut();
        }
        None
    }

    pub fn from_vec(vec: Vec<T>) -> Self {
        let mut list = Self::new();
        for v in vec {
            list.push_back(v);
        }
        list
    }

    pub fn into_vec(mut self) -> Vec<T> {
        let mut vec = vec![];
        while let Some(value) = self.pop_front() {
            vec.push(value);
        }
        vec
    }

    pub fn length(&self) -> usize {
        let mut count = 0;
        let mut current = &self.head;
        while let Some(ref node) = current {
            count += 1;
            current = &node.next;
        }
        count
    }

    pub fn map<F: Fn(T) -> T>(self, f: F) -> Self {
        let mut new_list = Self::new();
        let mut current = self.head;
        while let Some(node) = current {
            new_list.push_back(f(node.value));
            current = node.next;
        }
        new_list
    }

    pub fn pair_map<F: Fn(T, T) -> T>(self, f: F) -> Self
    where
        T: Clone,
    {
        let mut new_list = Self::new();
        let mut current = self.head;
        while let Some(node1) = current {
            if let Some(node2) = node1.next {
                new_list.push_back(f(node1.value.clone(), node2.value.clone()));
                current = node2.next;
            } else {
                break;
            }
        }
        new_list
    }
}

impl<T: Debug> SinglyLinkedList<SinglyLinkedList<T>> {
    pub fn flatten(self) -> SinglyLinkedList<T> {
        let mut flattened = SinglyLinkedList::new();
        let mut current = self.head;
        while let Some(list_node) = current {
            let list = list_node.value;
            let mut sub_list_current = list.head;
            while let Some(sub_node) = sub_list_current {
                flattened.push_back(sub_node.value);
                sub_list_current = sub_node.next;
            }
            current = list_node.next;
        }
        flattened
    }
}
```
```rust
use std::fmt::Debug;

/// Node of the list.
#[derive(Debug)]
pub struct Node<T: Debug> {
    pub value: T,
    pub next: Option<Box<Node<T>>>,
}

impl<T: Debug> Node<T> {
    pub fn new(value: T) -> Self {
        Self { value, next: None }
    }
}

/// A singly-linked list.
#[derive(Debug)]
pub struct SinglyLinkedList<T: Debug> {
    head: Option<Box<Node<T>>>,
}

impl<T: Debug> Default for SinglyLinkedList<T> {
    fn default() -> Self {
        Self::new()
    }
}

impl<T: Debug> SinglyLinkedList<T> {
    pub fn new() -> Self {
        Self { head: None }
    }

    pub fn push_front(&mut self, value: T) {
        let mut new_node = Box::new(Node::new(value));
        new_node.next = self.head.take();
        self.head = Some(new_node);
    }

    pub fn push_back(&mut self, value: T) {
        let mut new_node = Box::new(Node::new(value));
        if let Some(mut node) = self.head.as_mut() {
            while let Some(ref mut next) = node.next {
                node = next;
            }
            node.next = Some(new_node);
        } else {
            self.head = Some(new_node);
        }
    }

    pub fn pop_front(&mut self) -> Option<T> {
        self.head.take().map(|mut node| {
            self.head = node.next.take();
            node.value
        })
    }

    pub fn pop_back(&mut self) -> Option<T> {
        let mut current = self.head.as_mut();
        let mut prev: Option<&mut Box<Node<T>>> = None;

        while let Some(ref mut node) = current {
            if node.next.is_none() {
                break;
            }
            prev = current;
            current = node.next.as_mut();
        }

        match prev {
            Some(prev) => prev.next.take().map(|node| node.value),
            None => self.head.take().map(|node| node.value),
        }
    }

    pub fn from_vec(vec: Vec<T>) -> Self {
        let mut list = Self::new();
        for value in vec.into_iter().rev() {
            list.push_front(value);
        }
        list
    }

    pub fn into_vec(self) -> Vec<T> {
        let mut vec = Vec::new();
        let mut current = self.head;
        while let Some(node) = current {
            vec.push(node.value);
            current = node.next;
        }
        vec
    }

    pub fn length(&self) -> usize {
        let mut count = 0;
        let mut current = self.head.as_ref();
        while let Some(node) = current {
            count += 1;
            current = node.next.as_ref();
        }
        count
    }

    pub fn map<F: Fn(T) -> T>(self, f: F) -> Self {
        let mut result = Self::new();
        let mut current = self.head;
        while let Some(mut node) = current {
            result.push_back(f(node.value));
            current = node.next;
        }
        result
    }

    pub fn pair_map<F: Fn(T, T) -> T>(self, f: F) -> Self
    where
        T: Clone,
    {
        let mut result = Self::new();
        let mut current = self.head.as_ref();
        while let Some(node) = current {
            if let Some(next) = node.next.as_ref() {
                result.push_back(f(node.value.clone(), next.value.clone()));
            }
            current = node.next.as_ref();
        }
        result
    }
}

impl<T: Debug> SinglyLinkedList<SinglyLinkedList<T>> {
    pub fn flatten(self) -> SinglyLinkedList<T> {
        let mut result = SinglyLinkedList::new();
        let mut current = self.head;
        while let Some(mut list_node) = current {
            let mut inner_current = list_node.value.head;
            while let Some(mut inner_node) = inner_current {
                result.push_back(inner_node.value);
                inner_current = inner_node.next.take();
            }
            current = list_node.next;
        }
        result
    }
}
```
```rust
use std::fmt::Debug;

#[derive(Debug)]
pub struct Node<T: Debug> {
    pub value: T,
    pub next: Option<Box<Node<T>>>,
}

impl<T: Debug> Node<T> {
    pub fn new(value: T) -> Self {
        Self { value, next: None }
    }
}

#[derive(Debug)]
pub struct SinglyLinkedList<T: Debug> {
    head: Option<Box<Node<T>>>,
}

impl<T: Debug> Default for SinglyLinkedList<T> {
    fn default() -> Self {
        Self::new()
    }
}

impl<T: Debug> SinglyLinkedList<T> {
    pub fn new() -> Self {
        Self { head: None }
    }

    pub fn push_front(&mut self, value: T) {
        let new_node = Box::new(Node {
            value,
            next: self.head.take(),
        });
        self.head = Some(new_node);
    }

    pub fn push_back(&mut self, value: T) {
        let new_node = Box::new(Node::new(value));
        match self.head.as_mut() {
            Some(mut current) => {
                while let Some(next) = current.next.as_mut() {
                    current = next;
                }
                current.next = Some(new_node);
            }
            None => {
                self.head = Some(new_node);
            }
        }
    }

    pub fn pop_front(&mut self) -> Option<T> {
        self.head.take().map(|node| {
            self.head = node.next;
            node.value
        })
    }

    pub fn pop_back(&mut self) -> Option<T> {
        match self.head.take() {
            Some(node) => {
                if node.next.is_none() {
                    // Only one element
                    Some(node.value)
                } else {
                    // More than one element
                    let mut prev = node;
                    let mut current = prev.next.take();

                    while let Some(mut maybe_next) = current {
                        if maybe_next.next.is_none() {
                            prev.next = None;
                            return Some(maybe_next.value);
                        }
                        prev = maybe_next;
                        current = prev.next.take();
                    }
                    None
                }
            }
            None => None,
        }
    }

    pub fn from_vec(vec: Vec<T>) -> Self {
        let mut list = Self::new();
        for val in vec.into_iter().rev() {
            list.push_front(val);
        }
        list
    }

    pub fn into_vec(self) -> Vec<T> {
        let mut vec = Vec::new();
        let mut current = self.head;
        while let Some(node) = current {
            vec.push(node.value);
            current = node.next;
        }
        vec
    }

    pub fn length(&self) -> usize {
        let mut count = 0;
        let mut current = &self.head;
        while let Some(node) = current {
            count += 1;
            current = &node.next;
        }
        count
    }

    pub fn map<F: Fn(T) -> T>(self, f: F) -> Self {
        let mut new_list = SinglyLinkedList::new();
        let mut current = self.head;
        while let Some(node) = current {
            new_list.push_back(f(node.value));
            current = node.next;
        }
        new_list
    }

    pub fn pair_map<F: Fn(T, T) -> T>(self, f: F) -> Self
    where
        T: Clone,
    {
        let mut new_list = SinglyLinkedList::new();
        let mut current = self.head;
        while let Some(node) = current {
            if let Some(next_node) = &node.next {
                new_list.push_back(f(node.value.clone(), next_node.value.clone()));
                current = &node.next;
            } else {
                break;
            }
        }
        new_list
    }
}

impl<T: Debug> SinglyLinkedList<SinglyLinkedList<T>> {
    pub fn flatten(self) -> SinglyLinkedList<T> {
        let mut flat_list = SinglyLinkedList::new();
        let mut current = self.head;
        while let Some(mut node) = current {
            let sub_list = node.value;
            let mut sub_current = sub_list.head;
            while let Some(sub_node) = sub_current {
                flat_list.push_back(sub_node.value);
                sub_current = sub_node.next;
            }
            current = node.next;
        }
        flat_list
    }
}
```
```rust
use std::fmt::Debug;

/// Node of the list.
#[derive(Debug)]
pub struct Node<T: Debug> {
    /// Value of current node.
    pub value: T,

    /// Pointer to the next node. If it is `None`, there is no next node.
    pub next: Option<Box<Node<T>>>,
}

impl<T: Debug> Node<T> {
    /// Creates a new node.
    pub fn new(value: T) -> Self {
        Self { value, next: None }
    }
}

/// A singly-linked list.
#[derive(Debug)]
pub struct SinglyLinkedList<T: Debug> {
    /// Head node of the list. If it is `None`, the list is empty.
    head: Option<Box<Node<T>>>,
}

impl<T: Debug> Default for SinglyLinkedList<T> {
    fn default() -> Self {
        Self::new()
    }
}

impl<T: Debug> SinglyLinkedList<T> {
    /// Creates a new list.
    pub fn new() -> Self {
        Self { head: None }
    }

    /// Adds the given node to the front of the list.
    pub fn push_front(&mut self, value: T) {
        let new_node = Box::new(Node {
            value,
            next: self.head.take(),
        });
        self.head = Some(new_node);
    }

    /// Adds the given node to the back of the list.
    pub fn push_back(&mut self, value: T) {
        let new_node = Box::new(Node::new(value));

        match self.head.as_mut() {
            Some(mut current) => {
                while let Some(ref mut next) = current.next {
                    current = next;
                }
                current.next = Some(new_node);
            }
            None => {
                self.head = Some(new_node);
            }
        }
    }

    /// Removes and returns the node at the front of the list.
    pub fn pop_front(&mut self) -> Option<T> {
        self.head.take().map(|node| {
            self.head = node.next;
            node.value
        })
    }

    /// Removes and returns the node at the back of the list.
    pub fn pop_back(&mut self) -> Option<T> {
        let mut current = self.head.as_mut()?;
        if current.next.is_none() {
            self.head.take().map(|node| node.value)
        } else {
            while current.next.as_ref()?.next.is_some() {
                current = current.next.as_mut()?;
            }
            current.next.take().map(|node| node.value)
        }
    }

    /// Create a new list from the given vector `vec`.
    pub fn from_vec(vec: Vec<T>) -> Self {
        let mut list = SinglyLinkedList::new();
        for value in vec.into_iter().rev() {
            list.push_front(value);
        }
        list
    }

    /// Convert the current list into a vector.
    pub fn into_vec(mut self) -> Vec<T> {
        let mut vec = Vec::new();
        while let Some(value) = self.pop_front() {
            vec.push(value);
        }
        vec
    }

    /// Return the length (i.e., number of nodes) of the list.
    pub fn length(&self) -> usize {
        let mut count = 0;
        let mut current = &self.head;
        while let Some(node) = current {
            count += 1;
            current = &node.next;
        }
        count
    }

    /// Apply function `f` on every element of the list.
    pub fn map<F: Fn(T) -> T>(self, f: F) -> Self {
        let mut list = SinglyLinkedList::new();
        let mut current = self.head;
        while let Some(node) = current {
            list.push_back(f(node.value));
            current = node.next;
        }
        list
    }

    /// Apply given function `f` for each adjacent pair of elements in the list.
    pub fn pair_map<F: Fn(T, T) -> T>(self, f: F) -> Self
    where
        T: Clone,
    {
        let mut list = SinglyLinkedList::new();
        let mut current = &self.head;
        while let (Some(first), Some(second)) = (current, current.as_ref()?.next.as_ref()) {
            list.push_back(f(first.value.clone(), second.value.clone()));
            current = &second.next;
        }
        list
    }
}

// A list of lists.
impl<T: Debug> SinglyLinkedList<SinglyLinkedList<T>> {
    /// Flatten the list of lists into a single list.
    pub fn flatten(self) -> SinglyLinkedList<T> {
        let mut list = SinglyLinkedList::new();
        let mut current = self.head;
        while let Some(node) = current {
            let nested_list = node.value;
            for value in nested_list.into_vec() {
                list.push_back(value);
            }
            current = node.next;
        }
        list
    }
}
```
```rust
use std::fmt::Debug;

/// Node of the list.
#[derive(Debug)]
pub struct Node<T: Debug> {
    pub value: T,
    pub next: Option<Box<Node<T>>>,
}

impl<T: Debug> Node<T> {
    pub fn new(value: T) -> Self {
        Self { value, next: None }
    }
}

/// A singly-linked list.
#[derive(Debug)]
pub struct SinglyLinkedList<T: Debug> {
    head: Option<Box<Node<T>>>,
}

impl<T: Debug> Default for SinglyLinkedList<T> {
    fn default() -> Self {
        Self::new()
    }
}

impl<T: Debug> SinglyLinkedList<T> {
    pub fn new() -> Self {
        Self { head: None }
    }

    pub fn push_front(&mut self, value: T) {
        let new_node = Box::new(Node {
            value,
            next: self.head.take(),
        });
        self.head = Some(new_node);
    }

    pub fn push_back(&mut self, value: T) {
        let mut new_node = Box::new(Node::new(value));
        
        match self.head.as_mut() {
            None => self.head = Some(new_node),
            Some(mut node) => {
                while let Some(next_node) = node.next.as_mut() {
                    node = next_node;
                }
                node.next = Some(new_node);
            }
        }
    }

    pub fn pop_front(&mut self) -> Option<T> {
        self.head.take().map(|boxed_node| {
            self.head = boxed_node.next;
            boxed_node.value
        })
    }

    pub fn pop_back(&mut self) -> Option<T> {
        self.head.as_mut().take().and_then(|mut node| {
            if node.next.is_none() {
                return Some(node.value);
            }
            let mut current = &mut *node;
            while let Some(next_node) = current.next.as_mut() {
                if next_node.next.is_none() {
                    return current.next.take().map(|last| last.value);
                }
                current = next_node;
            }
            None
        })
    }

    pub fn from_vec(vec: Vec<T>) -> Self {
        let mut list = Self::new();
        for value in vec.into_iter().rev() {
            list.push_front(value);
        }
        list
    }

    pub fn into_vec(mut self) -> Vec<T> {
        let mut vec = Vec::new();
        while let Some(value) = self.pop_front() {
            vec.push(value);
        }
        vec
    }

    pub fn length(&self) -> usize {
        let mut count = 0;
        let mut current = &self.head;
        while let Some(node) = current {
            count += 1;
            current = &node.next;
        }
        count
    }

    pub fn map<F: Fn(T) -> T>(self, f: F) -> Self {
        let mut new_list = SinglyLinkedList::new();
        let mut current = &self.head;
        while let Some(node) = current {
            new_list.push_back(f(node.value.clone()));
            current = &node.next;
        }
        new_list
    }

    pub fn pair_map<F: Fn(T, T) -> T>(self, f: F) -> Self
    where
        T: Clone,
    {
        let mut new_list = SinglyLinkedList::new();
        let mut current = &self.head;
        while let Some(node) = current {
            if let Some(next_node) = &node.next {
                new_list.push_back(f(node.value.clone(), next_node.value.clone()));
            }
            current = &node.next;
        }
        new_list
    }
}

impl<T: Debug> SinglyLinkedList<SinglyLinkedList<T>> {
    pub fn flatten(self) -> SinglyLinkedList<T> {
        let mut flat_list = SinglyLinkedList::new();
        let mut current = self.head;
        while let Some(node) = current {
            let sub_list = node.value;
            let mut sub_current = sub_list.head;
            while let Some(sub_node) = sub_current {
                flat_list.push_back(sub_node.value);
                sub_current = sub_node.next;
            }
            current = node.next;
        }
        flat_list
    }
}
```
```rust
use std::fmt::Debug;

#[derive(Debug)]
pub struct Node<T: Debug> {
    pub value: T,
    pub next: Option<Box<Node<T>>>,
}

impl<T: Debug> Node<T> {
    pub fn new(value: T) -> Self {
        Self { value, next: None }
    }
}

#[derive(Debug)]
pub struct SinglyLinkedList<T: Debug> {
    head: Option<Box<Node<T>>>,
}

impl<T: Debug> Default for SinglyLinkedList<T> {
    fn default() -> Self {
        Self::new()
    }
}

impl<T: Debug> SinglyLinkedList<T> {
    pub fn new() -> Self {
        Self { head: None }
    }

    pub fn push_front(&mut self, value: T) {
        let new_node = Box::new(Node::new(value));
        if let Some(head) = self.head.take() {
            let mut new_node = new_node;
            new_node.next = Some(head);
            self.head = Some(new_node);
        } else {
            self.head = Some(new_node);
        }
    }

    pub fn push_back(&mut self, value: T) {
        let new_node = Box::new(Node::new(value));
        match self.head {
            Some(ref mut head) => {
                let mut current = head;
                while let Some(ref mut next) = current.next {
                    current = next;
                }
                current.next = Some(new_node);
            }
            None => self.head = Some(new_node),
        }
    }

    pub fn pop_front(&mut self) -> Option<T> {
        self.head.take().map(|mut head| {
            self.head = head.next.take();
            head.value
        })
    }

    pub fn pop_back(&mut self) -> Option<T> {
        match self.head {
            Some(ref mut head) => {
                if head.next.is_none() {
                    return self.head.take().map(|node| node.value);
                }
                let mut current = head;
                while let Some(ref mut next) = current.next {
                    if next.next.is_none() {
                        let value = next.value;
                        current.next = None;
                        return Some(value);
                    }
                    current = next;
                }
                None
            }
            None => None,
        }
    }

    pub fn from_vec(vec: Vec<T>) -> Self {
        let mut list = Self::new();
        for value in vec {
            list.push_back(value);
        }
        list
    }

    pub fn into_vec(self) -> Vec<T> {
        let mut vec = Vec::new();
        let mut current = self.head;
        while let Some(mut node) = current {
            vec.push(node.value);
            current = node.next.take();
        }
        vec
    }

    pub fn length(&self) -> usize {
        let mut count = 0;
        let mut current = &self.head;
        while let Some(ref node) = current {
            count += 1;
            current = &node.next;
        }
        count
    }

    pub fn map<F: Fn(T) -> T>(self, f: F) -> Self {
        let mut result = Self::new();
        let mut current = self.head;
        while let Some(mut node) = current {
            result.push_back(f(node.value));
            current = node.next.take();
        }
        result
    }

    pub fn pair_map<F: Fn(T, T) -> T>(self, f: F) -> Self
    where
        T: Clone,
    {
        let mut result = Self::new();
        let mut current = &self.head;
        while let Some(first_node) = current {
            if let Some(second_node) = &first_node.next {
                result.push_back(f(first_node.value.clone(), second_node.value.clone()));
            }
            current = &first_node.next;
        }
        result
    }
}

impl<T: Debug> SinglyLinkedList<SinglyLinkedList<T>> {
    pub fn flatten(self) -> SinglyLinkedList<T> {
        let mut result = SinglyLinkedList::new();
        let mut current = self.head;
        while let Some(mut outer_node) = current {
            let inner_list = outer_node.value;
            let mut inner_current = inner_list.head;
            while let Some(mut inner_node) = inner_current {
                result.push_back(inner_node.value);
                inner_current = inner_node.next.take();
            }
            current = outer_node.next.take();
        }
        result
    }
}
```
```rust
use std::fmt::Debug;

/// Node of the list.
#[derive(Debug)]
pub struct Node<T: Debug> {
    pub value: T,
    pub next: Option<Box<Node<T>>>,
}

impl<T: Debug> Node<T> {
    pub fn new(value: T) -> Self {
        Self { value, next: None }
    }
}

/// A singly-linked list.
#[derive(Debug)]
pub struct SinglyLinkedList<T: Debug> {
    head: Option<Box<Node<T>>>,
}

impl<T: Debug> Default for SinglyLinkedList<T> {
    fn default() -> Self {
        Self::new()
    }
}

impl<T: Debug> SinglyLinkedList<T> {
    pub fn new() -> Self {
        Self { head: None }
    }

    pub fn push_front(&mut self, value: T) {
        let new_node = Box::new(Node {
            value,
            next: self.head.take(),
        });
        self.head = Some(new_node);
    }

    pub fn push_back(&mut self, value: T) {
        let new_node = Box::new(Node::new(value));
        match self.head.as_mut() {
            Some(mut curr) => {
                while let Some(next) = curr.next.as_mut() {
                    curr = next;
                }
                curr.next = Some(new_node);
            }
            None => self.head = Some(new_node),
        }
    }

    pub fn pop_front(&mut self) -> Option<T> {
        self.head.take().map(|node| {
            self.head = node.next;
            node.value
        })
    }

    pub fn pop_back(&mut self) -> Option<T> {
        match self.head.as_mut() {
            Some(mut curr) => {
                if curr.next.is_none() {
                    return self.head.take().map(|node| node.value);
                }
                while let Some(ref mut next) = curr.next {
                    if next.next.is_none() {
                        return next.next.take().map(|node| node.value);
                    }
                    curr = next;
                }
            }
            None => return None,
        }
        None
    }

    pub fn from_vec(vec: Vec<T>) -> Self {
        let mut list = Self::new();
        for item in vec.into_iter().rev() {
            list.push_front(item);
        }
        list
    }

    pub fn into_vec(self) -> Vec<T> {
        let mut vec = Vec::new();
        let mut curr = self.head;
        while let Some(node) = curr {
            vec.push(node.value);
            curr = node.next;
        }
        vec
    }

    pub fn length(&self) -> usize {
        let mut count = 0;
        let mut curr = &self.head;
        while let Some(node) = curr {
            count += 1;
            curr = &node.next;
        }
        count
    }

    pub fn map<F: Fn(T) -> T>(self, f: F) -> Self {
        let mut mapped_list = SinglyLinkedList::new();
        let mut curr = self.head;
        while let Some(node) = curr {
            mapped_list.push_back(f(node.value));
            curr = node.next;
        }
        mapped_list
    }

    pub fn pair_map<F: Fn(T, T) -> T>(self, f: F) -> Self
    where
        T: Clone,
    {
        let mut pair_mapped_list = SinglyLinkedList::new();
        let mut curr = self.head;
        
        while let Some(node) = curr {
            if let Some(next_node) = &node.next {
                let new_value = f(node.value.clone(), next_node.value.clone());
                pair_mapped_list.push_back(new_value);
                curr = Some(&next_node);
            } else {
                break;
            }
        }
        pair_mapped_list
    }
}

// A list of lists.
impl<T: Debug> SinglyLinkedList<SinglyLinkedList<T>> {
    pub fn flatten(self) -> SinglyLinkedList<T> {
        let mut flattened_list = SinglyLinkedList::new();
        let mut curr = self.head;
        
        while let Some(mut sublist_node) = curr {
            if let Some(mut sublist) = sublist_node.value.head {
                while let Some(sublist_item) = sublist {
                    flattened_list.push_back(sublist_item.value);
                    sublist = sublist_item.next;
                }
            }
            curr = sublist_node.next;
        }
        
        flattened_list
    }
}
```
```rust
use std::fmt::Debug;

/// Node of the list.
#[derive(Debug)]
pub struct Node<T: Debug> {
    /// Value of current node.
    pub value: T,

    /// Pointer to the next node. If it is `None`, there is no next node.
    pub next: Option<Box<Node<T>>>,
}

impl<T: Debug> Node<T> {
    /// Creates a new node.
    pub fn new(value: T) -> Self {
        Self { value, next: None }
    }
}

/// A singly-linked list.
#[derive(Debug)]
pub struct SinglyLinkedList<T: Debug> {
    /// Head node of the list. If it is `None`, the list is empty.
    head: Option<Box<Node<T>>>,
}

impl<T: Debug> Default for SinglyLinkedList<T> {
    fn default() -> Self {
        Self::new()
    }
}

impl<T: Debug> SinglyLinkedList<T> {
    /// Creates a new list.
    pub fn new() -> Self {
        Self { head: None }
    }

    /// Adds the given node to the front of the list.
    pub fn push_front(&mut self, value: T) {
        let new_node = Box::new(Node {
            value,
            next: self.head.take(),
        });
        self.head = Some(new_node);
    }

    /// Adds the given node to the back of the list.
    pub fn push_back(&mut self, value: T) {
        let mut new_node = Box::new(Node::new(value));
        if let Some(mut current) = self.head.as_mut() {
            while let Some(next) = current.next.as_mut() {
                current = next;
            }
            current.next = Some(new_node);
        } else {
            self.head = Some(new_node);
        }
    }

    /// Removes and returns the node at the front of the list.
    pub fn pop_front(&mut self) -> Option<T> {
        self.head.take().map(|node| {
            self.head = node.next;
            node.value
        })
    }

    /// Removes and returns the node at the back of the list.
    pub fn pop_back(&mut self) -> Option<T> {
        let mut current = self.head.as_mut()?;
        if current.next.is_none() {
            return Some(self.head.take()?.value);
        }
        while let Some(next) = current.next.as_mut() {
            if next.next.is_none() {
                return current.next.take().map(|node| node.value);
            }
            current = next;
        }
        None
    }

    /// Create a new list from the given vector `vec`.
    pub fn from_vec(vec: Vec<T>) -> Self {
        let mut list = Self::new();
        for value in vec.into_iter() {
            list.push_back(value);
        }
        list
    }

    /// Convert the current list into a vector.
    pub fn into_vec(self) -> Vec<T> {
        let mut vec = Vec::new();
        let mut current = self.head;
        while let Some(node) = current {
            vec.push(node.value);
            current = node.next;
        }
        vec
    }

    /// Return the length (i.e., number of nodes) of the list.
    pub fn length(&self) -> usize {
        let mut count = 0;
        let mut current = &self.head;
        while let Some(node) = current {
            count += 1;
            current = &node.next;
        }
        count
    }

    /// Apply function `f` on every element of the list.
    pub fn map<F: Fn(T) -> T>(self, f: F) -> Self {
        let mut list = SinglyLinkedList::new();
        let mut current = self.head;
        while let Some(node) = current {
            list.push_back(f(node.value));
            current = node.next;
        }
        list
    }

    /// Apply given function `f` for each adjacent pair of elements in the list.
    pub fn pair_map<F: Fn(T, T) -> T>(self, f: F) -> Self
    where
        T: Clone,
    {
        let mut list = SinglyLinkedList::new();
        let mut current = self.head;
        while let Some(mut node) = current {
            if let Some(next_node) = node.next.take() {
                list.push_back(f(node.value.clone(), next_node.value.clone()));
                current = Some(next_node);
            } else {
                break;
            }
        }
        list
    }
}

// A list of lists.
impl<T: Debug> SinglyLinkedList<SinglyLinkedList<T>> {
    /// Flatten the list of lists into a single list.
    pub fn flatten(self) -> SinglyLinkedList<T> {
        let mut flat_list = SinglyLinkedList::new();
        let mut current = self.head;
        while let Some(node) = current {
            let list = node.value;
            let mut sub_current = list.head;
            while let Some(sub_node) = sub_current {
                flat_list.push_back(sub_node.value);
                sub_current = sub_node.next;
            }
            current = node.next;
        }
        flat_list
    }
}
```
